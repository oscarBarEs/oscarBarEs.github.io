// Class for a simple particle with no rotational motion
public class Particle
{
  ParticleSystem _ps;  // Reference to the parent ParticleSystem
  int _id;             // Id. of the particle (-)

  float _m;            // Mass of the particle (kg)
  PVector _s;          // Position of the particle (m)
  PVector _v;          // Velocity of the particle (m/s)
  PVector _a;          // Acceleration of the particle (m/(s·s))
  PVector _F;          // Force applied on the particle (N)
  float _energy;       // Energy (J)

  float _radius;       // Radius of the particle (m)
  color _color;        // Color of the particle (RGBA)
  float _lifeSpan;     // Total time the particle should live (s)
  float _timeToLive;   // Remaining time before the particle dies (s)

  Particle(ParticleSystem ps, int id, float m, PVector s, PVector v, float radius, color c, float lifeSpan)
  {
    _ps = ps;
    _id = id;

    _m = m;
    _s = s;
    _v = v;

    _a = new PVector(0.0, 0.0);
    _F = new PVector(0.0, 0.0);
    _energy = 0.0;

    _radius = radius;
    _color = c;
    _lifeSpan = lifeSpan;
    _timeToLive = _lifeSpan;
  }

  void setPos(PVector s)
  {
    _s = s;
  }

  void setVel(PVector v)
  {
    _v = v;
  }

  PVector getForce()
  {
    return _F;
  }

  float getEnergy()
  {
    return _energy;
  }

  float getRadius()
  {
    return _radius;
  }

  float getColor()
  {
    return _color;
  }

  float getTimeToLive()
  {
    return _timeToLive;
  }

  boolean isDead()
  {
    return (_timeToLive <= 0.0);
  }

  void update(float timeStep)
  {
    _timeToLive -= timeStep;

    updateSimplecticEuler(timeStep);
    updateEnergy();
  }

  PVector calculateAcceleration(PVector s, PVector v)
  {
    PVector a = new PVector();

    PVector Fpeso = PVector.mult(G, _m);  //Fuerza peso

    //Froz = Kd * v^2
    PVector Froz;

    if (v.mag() != 0)
    {
      PVector Vn = PVector.div(v, v.mag());
      float v2 = v.mag();
      float froz = v2 * Kd;
      Froz = PVector.mult(Vn, froz);
    } else
    {
      Froz = new PVector(0, 0);
    }

    PVector SumF = PVector.add(Fpeso, Froz);
      v.mags
    a = PVector.div(SumF, M);

    return a;
  }

  void updateSimplecticEuler(float timeStep)
  {
    updateForce();

    //Calcular aceleración a
    PVector a = calculateAcceleration(_s, _v);
    //Calcular v(i+1) = v(i) + a(i)*dt
    _v.add(PVector.mult(a, timeStep));
    //Calcular s(i+1)=s(i) + v(i)*dt
    _s.add(PVector.mult(_v, timeStep));
  }

  void updateForce()
  {
    //
    //
    //
  }

  void updateEnergy()
  {
    //
    //
    //
  }

  void render(boolean useTexture)
  {
    if (useTexture)
    {
      PImage img = loadImage("texture.jpg");
      imageMode(CENTER);
      tint(255, _lifeSpan);
      image(img, _s.x, _s.y, _radius, _radius);
    } else
    {
      fill(112, 94, 216, _lifeSpan);
      noStroke();
      ellipse(_s.x, _s.y, _radius, _radius);
    }
  }
}
